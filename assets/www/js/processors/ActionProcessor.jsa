/**
 * @ngdoc Services
 * @name ActionProcessor
 * @description
 *   Implementation of {@link ActionProcessor}

 * @param {object} http Put description for http
 * @param {object} rootScope Put description for rootScope
 * @param {object} q Put description for q
 * @param {object} location Put description for location
 * @param {object} TemplateProcessor Put description for template processor
 * @param {object} AuthenticationEventHandler Put description for authentication event handler
 * @param {object} EncryptedCacheService Put description for encrypted cache service
 */

AppController.factory('ActionProcessor', ['$http','$injector','$rootScope', '$q', '$location', '$timeout', 'TemplateProcessor','AuthenticationEventHandler', 'EncryptedCacheService', 'ValidationService','UIControlsService','EncryptDecryptService', 'UIStubsService', 'MBaaS','Logger','HTTPConnector','CampaignProcessor','LocaleProcessor','MenuProfileConfigProcessor','StepupAuthenticateProcessor','MenuUIAccessProcessor',
                                          function($http,$injector,$rootScope, $q, $location, $timeout, TemplateProcessor, AuthenticationEventHandler, EncryptedCacheService, ValidationService,UIControlsService,EncryptDecryptService, UIStubsService, MBaaS, Logger,HTTPConnector,CampaignProcessor,LocaleProcessor,MenuProfileConfigProcessor,StepupAuthenticateProcessor,MenuUIAccessProcessor) {

	// variables that will be used across this service
	var featuresList;
	var appInitialized = false;
	var currentPage = '';
	var currentSubFeature = '';
	var currentSuccessResponse = {};
	var currentErrorResponse = {};
	var invokedFromLoginFlow = false;
	var encryptionEnabled = false;
	var isMbaasConnected = true;
	var serverConfig = {};


	singleStepAuthRealmChallengeHandler.initialize();
	singleStepAuthRealmChallengeHandler.bind('authRequired',function(data){
		//remove the spinner here.
		Logger.info("authRequired event triggered");
		//fire the setEvent for opening up login page click.
		if(currentPage == "RetailUserLoginPage" ){
			return;
		}
		if(currentPage == "FinacleLocationListPage" || currentPage == "FinacleLocationDetailsPage" ){
			return;
		}
		Logger.info("Redirecting to login screen now.");
		UIControlsService.showAlertOverlayScreen($rootScope.appLiterals.APP.ERROR_MESSAGE.INVALID_SES,$rootScope.appLiterals.APP.BUTTON_TEXT.OK);
		redirectToLoginOnSessionTimeout();		
	});
	singleStepAuthRealmChallengeHandler.bind('authFailure',function(data){
//		data.responseJSON.result={"errorMessage":"Login and Transaction Passwords Expired","forceLoginPassword":"TRUE","sessKey":"pEJI3-CRkILKG-IqTW11I2x4","mbParam":"hDu2KZE613BPZMfLGvf6ppCeeZ8yNCgKTf1UcWVuh8mr58r0M5yb1Ssy0n4R","forceTxnPassword":"TRUE","statusCode":200,"statusReason":"OK","responseHeaders":{"Date":"Tue, 31 Mar 2015 12:50:08 GMT","Expires":"0","Server":"Apache-Coyote/1.1","Pragma":"no-cache","Cache-Control":"no-cache"},"responseTime":26617,"totalTime":26618,"isSuccessful":true};

		// For force change password flow, credentials are being cleared on click of OK button in success screen.

		if( data.responseJSON.result.forceLoginPassword == "TRUE" || data.responseJSON.result.forceTxnPassword == "TRUE")
		{
			MF.log(data.responseJSON.result.errorMessage);
			displayErrorMessage = data.responseJSON.result.errorMessage;
			$rootScope.forcePasswordModel = data; 
			//new App.viewModels.myProfile().forcePasswordMessagePageOnLoad(data.responseJSON.result);
		}
		else
		{
            $rootScope.fields.finacleUserCorporateId ='';
            $rootScope.fields.finacleUserPassword ='';
			MF.log(data.responseJSON.result.errorMessage);

			// Server not responding valid JSON.
			if (typeof data.responseJSON.result.errorMessage === "undefined")
			{
//				displayErrorMessage = data.responseJSON.result;
				displayErrorMessage = $rootScope.appLiterals.APP.ERROR_MESSAGE.CON_ERROR;
			}
			else
			{
				displayErrorMessage = data.responseJSON.result.errorMessage;
			}
			UIControlsService.showAlertOverlayScreen(displayErrorMessage, $rootScope.appLiterals.APP.BUTTON_TEXT.OK);
		}

		$rootScope.$apply();
		invokedFromLoginFlow = true;
		if( (data.responseJSON.result.forceLoginPassword == "TRUE" || data.responseJSON.result.forceTxnPassword == "TRUE")
				&& $rootScope.appVersionDetails.appConfigParams[1].BUILDTYPE == 'PWD')
		{
			redirectToExpireLoginOnError();
		}
		else
		{
			redirectToLoginOnError();
		}

		invokedFromLoginFlow = false;

	});
	singleStepAuthRealmChallengeHandler.bind('authSuccess',function(data){
		//remove the spinner here.
		$rootScope.isUserLoggedIn = true;
		Logger.fatal("authSuccess event emitted");
	});

	var redirectToLoginOnError = function (){
		currentPage = 'RetailUserLoginPage';
		currentSubFeature = 'RetailUserLogin';
		$location.path(TemplateProcessor.getUrlForPage('RetailUserLoginPage'));
		$rootScope.$apply();
	};
	var logoutFromMFPRealm = function(){
		WL.Client.logout("SingleStepAuthRealm",{onSuccess: function(response){
			Logger.info("Logout triggered success : "+ JSON.stringify(response));
			setTimeout(function(){
				WL.Client.reloadApp();
			},1);
		},
		onFailure:function(errorResponse){
			Logger.info("Logout triggered failed : "+ JSON.stringify(errorResponse));
			setTimeout(function(){
				WL.Client.reloadApp();
			},1);
		}
		});
	};

	var redirectToLoginOnSessionTimeout = function (){
//		setTimeout(function(){
//		WL.Client.reloadApp();
//		},3000);	
		logoutFromMFPRealm();
	};
	var checkIfMapPageIsLoaded = function(){
		if(currentPage == "FinacleLocationListPage" || currentPage == "FinacleLocationDetailsPage" ){
			$rootScope.fields.isMapPage = true;
		}
		else{
			$rootScope.fields.isMapPage = false;
		}
	};

	var redirectToExpireLoginOnError = function (){
		currentPage = 'ForcePasswordChangeMessage';
		currentSubFeature = 'MyProfile';
		$location.path(TemplateProcessor.getUrlForPage('ForcePasswordChangeMessage'));
		$rootScope.$apply();
	};

	$rootScope.setSingleStepRealmAuthFailure = function(){
		singleStepAuthRealmChallengeHandler.submitFailure();
		singleStepAuthRealmChallengeHandler.isChallengeInProgress = false;
		logger.fatal("auth is Failure " + singleStepAuthRealmChallengeHandler);
	};
	$rootScope.setLocalizedLiteralsForLocale = function(locale) {
		return TemplateProcessor.setLocalizedLiteralsForLocale(locale);
	};
	/*
	 * The following will consolidate all the functions for MF invocation
	 * However, this will be an angular service going forward, abstracting all the worklight WL calls
	 */
	var MF = {
			//
			getCurrentLocation:function(callback,options){
				options = {
						enableHighAccuracy: false,
						timeout: 5000,
						maximumAge: 0
				};
				function success(pos) {

					$rootScope.currentLocation = {"isSuccess":true,"position":pos,"isInProgress":false};
					$rootScope.map = { center: {latitude:pos.coords.latitude,
						longitude:pos.coords.longitude}, zoom: 10 };
					$rootScope.marker = {
							id: 0,
							coords : {
								latitude: pos.coords.latitude ,
								longitude:  pos.coords.longitude
							},
							options: { draggable: true },
							events: {
								dragend: function (marker, eventName, args) {
									var lat = marker.getPosition().lat();
									var lon = marker.getPosition().lng();
									$rootScope.marker.options = {
											draggable: true,
											labelContent: "Hello",
											labelAnchor: "100 0",
											labelClass: "marker-labels"
									};
								},
//								click:function(marker,eventName,args){
//								$rootScope.showMarkerInfoFlag = {"isVisible":true};
//								alert("Map marker");
//								$rootScope.$apply();
								click: function(marker, eventName, args) {
//									MF.log('shomarkerflag '+ $rootScope.showMarkerInfoFlag);
//									$rootScope.showMarkerInfoFlag = true;
									$rootScope.showMarkerInfo();
									MF.log('shomarkerflag '+ $rootScope.showMarkerInfoFlag);
								}
//								}
							},
							control:{}
					};
					pos.coords.latitude = pos.coords.latitude.toFixed(4); // by default returns high precision data, this is to increase search boundaries.
					pos.coords.longitude = pos.coords.longitude.toFixed(4); // by default returns high precision data, this is to increase search boundaries.
					var crd = pos.coords;
					MF.log('Your current position is:');
					MF.log('Latitude : ' + crd.latitude);
					MF.log('Longitude: ' + crd.longitude);
					MF.log('More or less ' + crd.accuracy + ' meters.');
					callback.onSuccess(pos);
				}
				function error(err) {
					$rootScope.currentLocation = {"isSuccess":false,"position":{},"isInProgress":false};
					MF.log('ERROR(' + err.code + '): ' + err.message);
					callback.onFailure(err);
				}
				$rootScope.currentLocation = {"isSuccess":false,"position":{},"isInProgress":true};
				navigator.geolocation.getCurrentPosition(success, error, options);
			},
			log:function(message){
				Logger.info(message);
			}
	};



	/*
	 * invokeMFPHTTPService - Is used only for invoking mobilefirst services/adapters. It operates over HTTP.
	 * callback(error,response) - 
	 * First argument if not null, indicates no error. example : if (error){ // invocation failed }
	 * The following abstracted function must be part of DI environment, where in different 
	 * connectors must be able to plug in and play. 
	 * This abstraction below is WIP. Will move to a angular service.  
	 */
	var invokeMFPHTTPService = function(request,callback,showLoaderFlag){
		Logger.info("The invocation data in global method is " + JSON.stringify(request));

		$rootScope.prevRequest = request;

		if($rootScope.isStubbedVersion){
			//if(true){

			$timeout(
					function() {
						var response = UIStubsService.getResponse(request);

						if ($rootScope.prevRequest.adapter == "AuthenticationService") {
							$rootScope.isUserLoggedIn = true;
						}

						if ($rootScope.prevRequest.adapter == "LogoutService") {
							$rootScope.isUserLoggedIn = false;
						}					

						isMbaasConnected = true;
//						Logger.info("invokeMFPHTTPService success " + JSON.stringify(response));
						if(!angular.isUndefined(response.invocationResult.isSuccessful)){
							Logger.info("is successful -> " + response.invocationResult.isSuccessful);
						}
						var isSuccessful = response.invocationResult.isSuccessful; 
						if(response.invocationResult.response){
							// If we are here, it means this service invocation was a success.
							// However, before we conclude that the service invocation was successful,
							// we have to check for situations where MBanking/EBanking/CoreBanking were not
							// down. Interestingly, when one of these back end systems is down, we get
							// a successful message from mBaas. The only way to find out that everything
							// went fine is to check for the errors flag and errorMessage flag.
							// To check if there were errors, let us run through all the responses

							var responseJson=null;
							// put check for JSON OBJ
							if( typeof response.invocationResult.response =="object"){
								responseJson = response.invocationResult.response;
								callback(false, responseJson);	
								return;
							}
							else{
								responseJson = JSON.parse(response.invocationResult.response);
							}
							var allResponses = responseJson.responsesList;
							var errorResponseFlag = false;
							var errorMessageStr = '';
							for (var index = 0; index < allResponses.length; index++ ) {
								var thisResponse = allResponses[index];

								if (thisResponse.errors) {
									// There was an error.
									// So, we will get all the error messages and break
									errorResponseFlag = true;
									// This is a system error. We cannot show these errors to the
									// the end user (Things like json parsing error, etc). We will
									// put a custom message here
									errorMessageStr = $rootScope.appLiterals.APP.ERROR_MESSAGE.INT_SYS_ERROR;
									break;
								}

								if (thisResponse.errorMessage) {
									// There was an error.
									// So, we will get all the error messages and break
									errorResponseFlag = true;
									errorMessageStr = thisResponse.errorMessage;
									break;
								}
							}

							// Let us see if there was an error
							if (errorResponseFlag) {
								// There was an error
								// Let us show the error. If the error message is more than 100 characters, trim
								// it.

								UIControlsService.showAlertOverlayScreen(errorMessageStr, $rootScope.appLiterals.APP.BUTTON_TEXT.OK);
								callback(responseJson, responseJson);
							} else {
								// There was no error. This was a successful invocation
								// The flag indicates there was no error
//								StepupAuthenticateProcessor.processRequest(responseJson);
								StepupAuthenticateProcessor.processRequest(response).then(function(stepUpObject){
									callback(!isSuccessful,responseJson);
								},
								function(error){
									callback(!isSuccessful,responseJson);
								});
									//callback(false, responseJson);	
							}
						}else{
//							new StepupAuthenticateProcessor();
							if(!StepupAuthenticateProcessor._isInitialized){
								StepupAuthenticateProcessor.init().then(function(){
									StepupAuthenticateProcessor.processRequest(response).then(function(stepUpObject){
										StepupAuthenticateProcessor._isInitialized = true;
										callback(!isSuccessful,response);
										
									},
									function(error){
										StepupAuthenticateProcessor._isInitialized = false;
										callback(!isSuccessful,response);
									});
								},function(error){
									//Error reading framework.json file. Handle this with a retry.
									StepupAuthenticateProcessor._isInitialized = false;
								});	
							}
							else{
								StepupAuthenticateProcessor.processRequest(response).then(function(stepUpObject){
									callback(!isSuccessful,response);
								},
								function(error){
									callback(!isSuccessful,response);
								});
							}
						}
					},
					200
			);


			return;
		}

		var invokeProcedure = function(){
			MBaaS.invokeService(request).then(
					function(response){

						isMbaasConnected = true;
						Logger.info("invokeMFPHTTPService success " + JSON.stringify(response));
						if(!angular.isUndefined(response.invocationResult.isSuccessful)){
							Logger.info("is successful -> " + response.invocationResult.isSuccessful);
						}
						var isSuccessful = response.invocationResult.isSuccessful; 
						if(response.invocationResult.response){
							// If we are here, it means this service invocation was a success.
							// However, before we conclude that the service invocation was successful,
							// we have to check for situations where MBanking/EBanking/CoreBanking were not
							// down. Interestingly, when one of these back end systems is down, we get
							// a successful message from mBaas. The only way to find out that everything
							// went fine is to check for the errors flag and errorMessage flag.
							// To check if there were errors, let us run through all the responses
							var responseJson=null;
							// put check for JSON OBJ
							if( typeof response.invocationResult.response =="object"){
								responseJson = response.invocationResult.response;
								callback(false, responseJson);	
								return;
							}
							else{
								responseJson = JSON.parse(response.invocationResult.response);
							}
							var allResponses = responseJson.responsesList;
							var errorResponseFlag = false;
							var errorMessageStr = '';
							for (var index = 0; index < allResponses.length; index++ ) {
								var thisResponse = allResponses[index];

								if (thisResponse.errors) {
									// There was an error.
									// So, we will get all the error messages and break
									errorResponseFlag = true;
									// This is a system error. We cannot show these errors to the
									// the end user (Things like json parsing error, etc). We will
									// put a custom message here
									errorMessageStr = $rootScope.appLiterals.APP.ERROR_MESSAGE.INT_SYS_ERROR;
									break;
								}

								if (thisResponse.errorMessage || thisResponse.genericErrorMsg) {
									// There was an error.
									// So, we will get all the error messages and break
									errorResponseFlag = true;

									errorMessageStr = thisResponse.errorMessage || thisResponse.genericErrorMsg;
									break;
								}
							}

							// Let us see if there was an error
							if (errorResponseFlag) {
								// There was an error
								// Let us show the error. If the error message is more than 100 characters, trim
								// it.

								UIControlsService.showAlertOverlayScreen(errorMessageStr, $rootScope.appLiterals.APP.BUTTON_TEXT.OK);
								callback(responseJson, responseJson);
							} else {
								// There was no error. This was a successful invocation
								// The flag indicates there was no error
								
								StepupAuthenticateProcessor.processRequest(response).then(function(stepUpObject){
									callback(!isSuccessful,responseJson);
								},
								function(error){
									callback(!isSuccessful,responseJson);
								});

								//callback(false, responseJson);	
							}
						}else{
							if(!StepupAuthenticateProcessor._isInitialized){
								StepupAuthenticateProcessor.init().then(function(){
									StepupAuthenticateProcessor.processRequest(response).then(function(stepUpObject){
										StepupAuthenticateProcessor._isInitialized = true;
										callback(!isSuccessful,response);
										
									},
									function(error){
										StepupAuthenticateProcessor._isInitialized = false;
										callback(!isSuccessful,response);
									});
								},function(error){
									//Error reading framework.json file. Handle this with a retry.
									StepupAuthenticateProcessor._isInitialized = false;
								});	
							}
							else{
								StepupAuthenticateProcessor.processRequest(response).then(function(stepUpObject){
									callback(!isSuccessful,response);
								},
								function(error){
									callback(!isSuccessful,response);
								});
							}
						}
					},
					function(errorResponse){ 
						isMbaasConnected = false;
						Logger.fatal("invokeMFPHTTPService Failure " + JSON.stringify(errorResponse));
//						$location.path(TemplateProcessor.getUrlForPage(currentPage));
//						$rootScope.$apply();
						UIControlsService.showAlertOverlayScreen(errorResponse.errorMsg, $rootScope.appLiterals.APP.BUTTON_TEXT.OK);
						callback(errorResponse,null);
					}

			);
			// End of MBaaS.invokeService
		};
		/*
		 * The following a network check callback, invoked in every service invocation
		 * This code will check reachabilty before invoking a service, gives additional scope to 
		 * handle network related errors
		 */
		wlInitOptions.onSuccess = function() {
			Logger.info("Initialized worklight for MFP : "+ isMbaasConnected);
			if(isMbaasConnected){
				invokeProcedure();
			}
			else{
				UIControlsService.showAlertOverlayScreen($rootScope.appLiterals.APP.ERROR_MESSAGE.CON_ERROR, $rootScope.appLiterals.APP.BUTTON_TEXT.OK);
				return;
			}
			if(singleStepAuthRealmChallengeHandler.isChallengeInProgress){
				// This is make sure the authentication challenge flow is not opening up the loader
				if(isMbaasConnected){
					$location.path('/navigation/common/resources/FinacleLoaderPage');
					$rootScope.$apply();
				}
			}
		};
		wlInitOptions.onFailure = function() {
			Logger.fatal("Error initializing worklight in MFP");
		};
		wlInitOptions.timeout = 300000;
		// Let us now initialize worklight
		WL.Client.init(wlInitOptions);
		/*
		 * The following event is registered to capture all network errors during the course of usage in the app.
		 */
		document.addEventListener(WL.Events.WORKLIGHT_IS_DISCONNECTED, function(data){ 
			Logger.info('Not Connected : '+ JSON.stringify(data));
			UIControlsService.showAlertOverlayScreen($rootScope.appLiterals.APP.ERROR_MESSAGE.CON_ERROR, $rootScope.appLiterals.APP.BUTTON_TEXT.OK);
//			redirectToLoginOnError();
			return;
//			WL.Client.reloadApp(); // TODO : implement app reload when there are any critical errors.
		}, false);
		document.addEventListener(WL.Events.WORKLIGHT_IS_CONNECTED , function(data){
			Logger.info('Connected to Worklight Server: '+ JSON.stringify(data));
		}, false);

//		WL.Device.getNetworkInfo(function (networkInfo) {
//		Logger.info("Found IP : " + networkInfo.ipAddress + " with status : "+ networkInfo.isNetworkConnected);
//		Logger.info("Challenge in progress : "+ singleStepAuthRealmChallengeHandler.isChallengeInProgress);
//		if(!networkInfo.isNetworkConnected){
//		UIControlsService.showAlertOverlayScreen("You're not connected to the internet, please check your connection and try again.", "OK");
//		return;
//		}
//		else{
////		if(isMbaasConnected){
////		invokeProcedure();
////		}
////		else{
////		UIControlsService.showAlertOverlayScreen("Looks like the banking server is not available, please try again later.", "OK");
////		return;
////		}					

//		}
//		});
	};

	/*
	 * getModelParameters is used to generate parameters specified service invocation.
	 * All request to mbaas will contain only one param which is the json object (with values)
	 * as specified in the template file.
	 * Remember, we cannot send mbaasParams as json object because the worklight js engine 
	 * on mbaas throws an error "Cannot find default value for object". In order to avoid
	 * that, we need to stringify the param and send it to the caller.
	 * The reason behind this error is, JSON objects get encoded before sending and received the same way
	 * or the JSON.parse is invoked by ddefault in the receiving end of mobilefirst service/adapter.
	 * This abstraction below is WIP. Will move to a angular service.  
	 */
	var getModelParameters = function(eventInfoParams,currentActionType){
		var mbaasParams = {}; var sensitiveKeys = []; var encryptedSensitiveKeys = [];
		var parameters = []; var paramValue = '';
		// Let us pass the parameters a required for the service
		for (var paramKey in eventInfoParams.parameters) {
			var selfEncryptedKeys = eventInfoParams.encryptedSensitiveFields;
			if(encryptionEnable){
				var encryptedKeys = eventInfoParams.sensitiveFields;
				for(var key in encryptedKeys){
					Logger.info("Value assessed " + encryptedKeys[key]);
					if(eventInfoParams.parameters[paramKey] == encryptedKeys[key]){
						// added by cm
						if(paramKey=="DYNAMIC_VARS"){
							dynamicKeyValueCreator(paramKey, eventInfoParams, mbaasParams,encryptionEnable,sensitiveKeys);
							break;
						}else{
						//sweet spot.
						Logger.info("Value to be encrypted " + encryptedKeys[key]);
						paramValue = $rootScope.$eval(encryptedKeys[key]);
						Logger.info("Value before encryption: " + paramValue);
						encryptedParam = EncryptDecryptService.encryption(paramValue);
						Logger.info("Value after encryption: " + encryptedParam);
						mbaasParams[paramKey] = encryptedParam;
						sensitiveKeys.push(paramKey);
						break;
						}
					}
					else{
						// added by CM
						if(paramKey=="DYNAMIC_VARS"){
							dynamicKeyValueCreator(paramKey, eventInfoParams, mbaasParams,encryptionEnable,sensitiveKeys);
						}else{
						paramValue = $rootScope.$eval(eventInfoParams.parameters[paramKey]);
						mbaasParams[paramKey] = paramValue;
						}
					}
				}
			}
			else{
				// added by CM
				if(paramKey=="DYNAMIC_VARS"){
					dynamicKeyValueCreator(paramKey, eventInfoParams, mbaasParams,encryptionEnable,sensitiveKeys);
				}else{
				paramValue = $rootScope.$eval(eventInfoParams.parameters[paramKey]);
				mbaasParams[paramKey] = paramValue;
				}
			}
			// Added for Touch id-password flow
			for (var key in selfEncryptedKeys){
                		Logger.info("Value assessed " + selfEncryptedKeys[key]);
                		if(eventInfoParams.parameters[paramKey] == selfEncryptedKeys[key]){
                   			paramValue = $rootScope.$eval(selfEncryptedKeys[key]);
                   			mbaasParams[paramKey] = paramValue;
                   			encryptedSensitiveKeys.push(paramKey);
                		}
           		}
		}
		if(encryptedSensitiveKeys.length!=0){
			mbaasParams.encryptedSensitiveKeys = encryptedSensitiveKeys;
		}
		
		if(encryptionEnable){
			mbaasParams.sensitiveKeys = sensitiveKeys;
		}

		for(var confCounter=0;confCounter<$rootScope.mobileAppConfig.appConfigData.appConfigParams.length;confCounter++){
			var keyname =Object.keys($rootScope.mobileAppConfig.appConfigData.appConfigParams[confCounter])[0];

			mbaasParams[keyname] = $rootScope.mobileAppConfig.appConfigData.appConfigParams[confCounter][keyname];
		}
		mbaasParams.USER_REQUEST_ID=$rootScope.userRequestId; 
		if($rootScope.devMode===true && $rootScope.setBankId!=undefined && $rootScope.setBankId!="" && $rootScope.setBankId!=""){
			
			mbaasParams.BANK_ID =$rootScope.setBankId;
			
		}
		else{
			mbaasParams.BANK_ID =$rootScope.mobileAppConfig.appConfigData.multiEntity.bankid;
		}
		mbaasParams.MBLocale = $rootScope.MBLocale;
		if(typeof currentActionType != 'undefined' && currentActionType == 'serviceExternal'){
			parameters.push(mbaasParams);
			return parameters;
		}
		/**
		 * MachineFingerPrint added
		 */
		mbaasParams.machineFingerPrint=$rootScope.machineFingerPrint;
		/**
		 * IPADDRESS added
		 */
		mbaasParams.ipAddress=$rootScope.IPADDRESS;
		
		//mbaasParams["adapter"]=eventInfoParams.action; // for MB node server support
		parameters.push(JSON.stringify(mbaasParams));
		return parameters;
	};
	
	var dynamicKeyValueCreator=function(paramKey, eventInfoParams, mbaasParams, encryptionEnable,sensitiveKeys){
		var paramKeyArr=eventInfoParams.parameters[paramKey];
		for(var paramCount=0; paramCount< paramKeyArr.length;paramCount++){
		var paramStringArr=paramKeyArr[paramCount].split(',');
		var list=$rootScope.$eval(paramStringArr[0]);
		var key =paramStringArr[1];
		var dynamicKeyName =paramStringArr[2];
			for (var count=0; count<list.length;count++){
				var paramVal=list[count][key];
				if(encryptionEnable==true){
					paramVal = EncryptDecryptService.encryption(paramVal);
					Logger.info("Value after encryption: " + paramVal);
					sensitiveKeys.push(dynamicKeyName+(count+1));
				}else
				mbaasParams[dynamicKeyName+(count+1)] = paramVal;
			}
		}
	}
	/*
	 * getNextActionSequenceObject will return the object for next course of action decisions.
	 */
	var getNextActionSequenceObject = function(eventInfo){
		var nextPage = eventInfo.successPage;
		var nextSubFeatureName = '';
		var nextPageName = '';
		// Check if the next page is within the same workflow
		// or a different one
		if (nextPage.hasOwnProperty('subFeature')) {
			// OK, we are moving to a new sub-feature
			nextSubFeatureName = nextPage.subFeature;
			nextPageName = nextPage.pageName;
		} else {
			// We are going to be in the same subFeature.
			nextSubFeatureName = currentSubFeature;
			nextPageName = nextPage.pageName;
		}
		// let us fetch the url for the page
		var pageUrl = TemplateProcessor.getUrlForPage(nextPageName);
		Logger.info("The next page is " + nextPageName + " with url " + pageUrl);
		Logger.info("The next subFeature is " + nextSubFeatureName);
		return {"nextPageName":nextPageName,"nextSubFeatureName":nextSubFeatureName,"pageUrl":pageUrl};
	};

	// function definitions
	return {

		// The init method which initializes the templates framework.
		// This function uses TemplateProcessor to process templates.
		init: function() {

			// Note that we will have to return a promise because the caller
			// is waiting on us to complete this functionality
			var deferred = $q.defer();
			//Open the encrypted cache
//			EncryptedCacheService.openCache();

			// Three things to do here.
			// Step 1. Initialize the TemplateProcessor
			// Step 2. Find out the launcher page
			// Step 3. Launch the first page

			// Let us initialize TemplateProcessor now
			TemplateProcessor.init().then(
					function(payload) {
						LocaleProcessor.init($rootScope.appVersionDetails).then(function(localeData) {
							MenuProfileConfigProcessor.init().then(function(menuProfileData) {
								MenuUIAccessProcessor.init().then(function(menuUIData) {
								Logger.debug("Locale configuration processed successfully : "+JSON.stringify(payload));
								Logger.info("TemplateProcessor's init completed successfully");
								appInitialized = true;
								//Logger.info("menu profile's init completed successfully"+JSON.stringify(menuProfileData));
							$rootScope.menuList=menuUIData.menuItems;
								$rootScope.favoriteList=menuProfileData.menuItems;

								// app literal values mapping for constant
								$rootScope.monthList=localeData.APP.CONSTANTS.MONTHS.split(',');
								$rootScope.days=localeData.APP.CONSTANTS.DAYS.split(',');

								// Step 2. Let's preload the server configurations file
								// This is required if there are any external server call in the init of first launch page
								serverConfig = TemplateProcessor.getAllServerConfig();
								// Step 3. Let us now find out the launcher page
								var featureStart = TemplateProcessor.getFeatureStart();
								currentSubFeature = featureStart;
								Logger.info("The subfeature to start is " + featureStart);
								var pageName = TemplateProcessor.getStartPageForSubFeature(featureStart);
								currentPage = pageName;
								var launchPage = TemplateProcessor.getUrlForPage(pageName);
								Logger.info("The start page is " + pageName + " with url " + launchPage);
								// Step 3. Let us now launch the page
								$location.path(launchPage);
								// Notify the one who is waiting on this promise
								deferred.resolve(payload);
								deferred.resolve(localeData);
		    				deferred.resolve(menuUIData);
								deferred.resolve(menuProfileData);
							}, function(errorMenuUIData)
			    				{
			    					Logger.debug("Error processing menu UI Access Configs");
				    				deffered.resolve(errorMenuUIData);
			    				});
							}, function(errorLocaleData) {
								Logger.debug("Error processing menu Profile configs");
								deffered.resolve(errorLocaleData);
							});
						}, function(errorLocaleData) {
							Logger.debug("Error processing locale configs");
							deffered.resolve(errorLocaleData);
						});


					}, function(errorPayload) {
						Logger.fatal("Error processing templates");
						deferred.reject(errorPayload);
					});

			// Let us return the promise now
			return deferred.promise;
		},
		// A method that tracks if the app was initialized
		isAppInitialized: function() {
			return appInitialized;
		},
		isUserLoggedIn:function(){
			Logger.info("isUserLoggedIn in actionprocessor");

			// This snippet is used to controll the isUserLoggedIn during stubbed mode
			if($rootScope.isStubbedVersion){
				return $rootScope.isUserLoggedIn;
			}

			// This is returned in a normal mode
			return singleStepAuthRealmChallengeHandler.isUserLoggedIn("");
		},
		registerNetworkReachability:function(callback){
			if(!callback){
				Logger.info("Signature for registerNetworkReachability is : registerNetworkReachability(callback). Error aborting.");
				return;
			}
//			WL.Device.get
		},
		setGlobalEvent:function(eventName,options){
			var deferred = $q.defer();
			var currentEventInfo = null;
			Logger.info("The event called was " + eventName + " in " + currentPage);
//			checkIfMapPageIsLoaded();
			/*
			 * Exceptional case as this event will have no hierarchy to check for now.
			 * However, error alert event will have feature hierarchies in upcoming sprints.
			 */
			if(eventName == "onErrorPageOKClick"){
				// Let us return the promise here, without which the caller will not
				// wait for us to return
				UIControlsService.hideAlertOverlayScreen();
				//Handle session timeout.
				if(currentErrorResponse.responsesList[0].errorCode === 101 || currentErrorResponse.responsesList[0].errorCode === 102){
					logoutFromMFPRealm();
				}
				return deferred.promise;
			}
			var workflow = TemplateProcessor.getWorkflowForSubFeature("FinacleCommon");
			workflow.pageNavigation.forEach(function(key,value){
				var globalEvents = workflow.pageNavigation[value][workflow.startPage];
				if(angular.isUndefined(globalEvents)){
					//Handle event not found error here, the return (below) inside forEach equals break. 
					return;
				}
				globalEvents.forEach(function(i,v){
					if(globalEvents[v].eventName == eventName){
						Logger.info("Global event info match in : "+ JSON.stringify(globalEvents[v]));
						currentEventInfo = globalEvents[v];
						return;
					}
					else{
						//Handle additional conditions here
						return;
					}
				});
			});

			Logger.info("Global event details : " + JSON.stringify(currentEventInfo));
			var formValid = true;
			if(currentEventInfo.validation == 'true'){
				Logger.info("Validations enabled for page: " + currentPage);
				var validationParams = currentEventInfo.validationParams;
				formValid = ValidationService.performValidation(validationParams);
				if(!formValid){
					deferred.reject();
				}
			}
			if(!formValid){
				//return
				deferred.reject();

				return;
			}
			if(currentEventInfo.hasOwnProperty('encryptionEnabled')){
				encryptionEnable = currentEventInfo.encryptionEnabled;
			}
			else{
				encryptionEnable = false;
			}
			var nextActionObject={};
			if(currentEventInfo.actionType == "show"){
				//Traverse to the fixed popover confirmation page designed.
				UIControlsService.showConfirmationScreen(currentEventInfo.message.title, currentEventInfo.message.body, currentEventInfo.message.ok, currentEventInfo.message.cancel);
			}
			else if(currentEventInfo.actionType == "confirmCancel"){
				//Cancel button touched
				var pageUrl = TemplateProcessor.getUrlForPage(currentPage);
				Logger.info("Global confirmation Cancel touched : "+ currentPage + " -- url "+ pageUrl);
				$location.path(pageUrl);
			}
			else if(currentEventInfo.actionType == "confirmOK" || currentEventInfo.actionType == "service" || currentEventInfo.actionType== "serviceNoNavigation"){
				//OK button touched
				Logger.info("Global confirmation OK touched");
				if(currentEventInfo.action.indexOf('Service') > -1){

					parameters = getModelParameters(currentEventInfo);
					var invocationData = {
							adapter: currentEventInfo.action,
							procedure: "processRequest",
							parameters: parameters
					};
					if(currentEventInfo.actionType != "serviceNoNavigation"){
						$location.path('/navigation/common/resources/FinacleLoaderPage');
					}

					Logger.info("The invocation data is " + JSON.stringify(invocationData));
					invokeMFPHTTPService(invocationData, function(error,response){
						if(error){
							//handle error
							Logger.fatal("Error in MFP invocation :" + error );
							Logger.fatal('Service invocation returned an error');
							currentErrorResponse = error;
							// Let us launch the error page
							var errorPage = currentEventInfo.errorPage;
							var pageUrl = TemplateProcessor.getUrlForPage(errorPage.pageName);
							Logger.fatal("The next page is " + errorPage + " with url " + pageUrl);
							if (errorPage.hasOwnProperty('subFeature')) {
								// OK, we are moving to a new sub-feature
								currentSubFeature = errorPage.subFeature;
							}
							currentPage = errorPage.pageName;

							$location.path(pageUrl);
							deferred.resolve(error);
							return;
						}
						Logger.info('Service invocation was successful');
						
						//Check for adaptive/stepup authentication flow.
						if($rootScope.stepupAuthentication.isEnabled){
							$rootScope.stepupAuthentication.currentState = currentEventInfo.successPage;
							currentEventInfo.successPage = $rootScope.stepupAuthentication.format.successPage;
						}
						if($rootScope.stepupAuthentication.isCompleted){
							currentEventInfo = $rootScope.stepupAuthentication.currentState;
							$rootScope.stepupAuthentication.currentState = null;
							$rootScope.stepupAuthentication.isCompleted = false;
						}
							
						
						// Let us launch the next page
						nextActionObject = getNextActionSequenceObject(currentEventInfo);
						currentSuccessResponse = response;
						
						
						if(currentEventInfo.actionType == "service"){
							$location.path(nextActionObject.pageUrl);
						}
						// We have all we need to move to the net page
						// Now that we have moved, let us remember which page we are in
						currentSubFeature = nextActionObject.nextSubFeatureName;
						currentPage = nextActionObject.nextPageName;
						if(currentEventInfo.actionType == "confirmOK"){
							if($rootScope.isStubbedVersion){
								$rootScope.isUserLoggedIn = false;
								$location.path(nextActionObject.pageUrl);
								$rootScope.$apply();
								Logger.info("Logout triggered success : "+ JSON.stringify(response));
								return;
							}
							logoutFromMFPRealm();
						}
						if($rootScope.isToggleMenuVisible){

						}
						deferred.resolve(response);
					},false);
				}
				else{
					//Assuming just a navigation could be a possible transition type
					nextActionObject = getNextActionSequenceObject(currentEventInfo);
					$location.path(nextActionObject.pageUrl);
					// Now that we have moved, let us remember which page we are in
					currentSubFeature = nextActionObject.nextSubFeatureName;
					currentPage = nextActionObject.nextPageName;
				}
			} else if(currentEventInfo.actionType == "navigation") {
				nextActionObject = getNextActionSequenceObject(currentEventInfo);
				$location.path(nextActionObject.pageUrl);
				// Now that we have moved, let us remember which page we are in
				currentSubFeature = nextActionObject.nextSubFeatureName;
				currentPage = nextActionObject.nextPageName;
			}

			// We have found the event by the time we are here
			// Let us invoke the service

			//added for support the global event in case of help enabled
			if($rootScope.toggleHelp && currentEventInfo.actionType != "show" && currentEventInfo.actionType != "confirmCancel"){
				$rootScope.toggleHelp = false;
			}
			return deferred.promise;
		},
		setEvent: function(eventName,flag) {
			var deferred = $q.defer();
			// We should not reset the cached responses.
			// Finacle mobile app will reuse cached responses.
			//currentSuccessResponse = {}; currentErrorResponse = {};
			Logger.info("The event called was " + eventName + " in " + currentPage);
//			checkIfMapPageIsLoaded();
			if (invokedFromLoginFlow) {
				// This is a special case handling for the loginFlow event.
				// Here, the onLoginLoad() event gets called within the procesing
				// of onLoginClick. We need to have to this check for handling
				// invalid login scenarios.
				Logger.fatal("Will not execute this event");
				deferred.resolve();
				return;
			}

			var workflow = TemplateProcessor.getWorkflowForSubFeature(currentSubFeature);
			// Let us identify the service to be invoked for this event
			var allPages = workflow.pageNavigation;
			// First, find the current page
			var index;
			for (index = 0; index < allPages.length; index++) {
				var thisPage = allPages[index];
				if (thisPage.hasOwnProperty(currentPage)) {
					// We found the page.
					break;
				}
			}
			// By the time we are here, we have found the page. Just in case, we have not, then it is
			// a serious exception
			if (index >= allPages.length) {
				Logger.fatal("Serious error. A page that was present in the configs has gone missing:" + currentPage);
				deferred.error({error: 'Internal error'});
				return;
			}
			// We found the page. Let us find the details of the event now
			var eventsIndex = 0;
			var currentPageEventsList = (allPages[index])[currentPage];
			// Let us now find the event and the corresponding action
			for (; eventsIndex < currentPageEventsList.length; eventsIndex++) {
				if (currentPageEventsList[eventsIndex].eventName == eventName) {
					// We found the event
					break;
				}
			}
			// We have found the event by the time we are here
			// Let us invoke the service
			var currentEventInfo = currentPageEventsList[eventsIndex];
			//Perform validations on the form if the validations is enabled.
			var formValid = true;

			// Check if the value is not defined. If so, then set it false by default.
			if (_.isUndefined(currentEventInfo.validation)) {
				currentEventInfo.validation = false;
			}

//			if($rootScope.isPassword){
////			alert('password field');
//			var passwordText = $("input[type='password']:first").val();
//			if(passwordText.match(' ')){
//			UIControlsService.showValidationAlert('Password should not allow spaces');
//			$("input[type='password']:first").css({"border-color": "red", 
//			"border-width":"1px", 
//			"border-style":"solid"});
//			return false;
//			}
//			else{
//			$rootScope.isPassword = false;
//			$("input[type='password']:first").css({"border-color": "#C1E0FF", 
//			"border-width":"1px", 
//			"border-style":"solid"});
//			}

//			}

			if(currentEventInfo.validation == 'true'){
				Logger.info("Validations enabled for page: " + currentPage);
				var validationParams = currentEventInfo.validationParams;
				formValid = ValidationService.performValidation(validationParams);

				// If there are errors, then check if a popup is required. If so, display it
				if(!formValid){

					var keyArr = Object.keys($rootScope.pageErrorCode);
					for (var i = 0; i < keyArr.length; i++) {
						if(currentEventInfo.validationErrorMessage && currentEventInfo.validationErrorMessage !== null){
							for (var j = 0; j < currentEventInfo.validationErrorMessage.length; j++) {
								var key = Object.keys(currentEventInfo.validationErrorMessage[j])[0];
								if ($rootScope.pageErrorCode[keyArr[i]] == key) {
									/* Commented by sudharsan to fetch message form literals								
									UIControlsService.showValidationAlert(currentEventInfo.validationErrorMessage[j][key]); */	
									var errMess=$rootScope.$eval('appLiterals.'+currentEventInfo.validationErrorMessage[j][key]);
									console.log("ErrorMessage: "+errMess);
									UIControlsService.showValidationAlert(errMess);
									deferred.reject();
								}
							}
						}
						deferred.reject();
					}
				}
			}

			// If there is no validation error, then proceed. 
			if(formValid){
				if(currentEventInfo.hasOwnProperty('encryptionEnabled')){
					encryptionEnable = currentEventInfo.encryptionEnabled;
				}
				else{
					encryptionEnable = false;
				}

				var service = currentEventInfo.action;
				var actionType = currentEventInfo.actionType;
				Logger.info("The action to invoke is " + service +" with type : "+ actionType);

				parameters = getModelParameters(currentEventInfo,actionType);
				Logger.info("Parameters to be posted are  " + JSON.stringify(parameters));

				if(eventName == "onOkClick"){ // This feature is now moved
					WL.Client.logout("SingleStepAuthRealm");
					$rootScope.isUserLoggedIn = false;
					Logger.info("Logout triggered");			
				}
				if(actionType == 'challengeresponse'){
					Logger.info("getChallengeResponseHandler " + service );
					parameters = getModelParameters(currentEventInfo);
					if(isMbaasConnected){
						$location.path('/navigation/common/resources/FinacleLoaderPage');
					}

					singleStepAuthRealmChallengeHandler.respondChallenge(parameters);
					Logger.info("*************getChallengeResponseHandler*************");
					deferred.resolve();
					return deferred.promise;
				}
				
				var nextActionObject = {};
				
				if(actionType == 'navigation'){
					Logger.info("*************navigation*************");
				    nextActionObject = getNextActionSequenceObject(currentEventInfo);
					// We have all we need to move to the net page
					$location.path(nextActionObject.pageUrl);
					// Now that we have moved, let us remember which page we are in
					currentSubFeature = nextActionObject.nextSubFeatureName;
					currentPage = nextActionObject.nextPageName;
					deferred.resolve();
					return deferred.promise;
				}
				// actionType is for help icon functionality
				else if(actionType == 'helpNavigation'){
					Logger.info("*************helpNavigation*************");
					nextActionObject = getNextActionSequenceObject(currentEventInfo);					
					//$location.path(nextActionObject.pageUrl);
					var pageUrl = TemplateProcessor.getUrlForPage(nextActionObject.nextPageName);
					$rootScope.showHelpIcon=true; // always true for helpnavigation
					// read the content of html fill in a div and overlay the div
					$rootScope.toggleHelp = !$rootScope.toggleHelp;
					if($rootScope.toggleHelp){
						$.ajax({
							url:pageUrl+'.html',
							async:false,
							success:function(data){
								$('#helpContent').html(data);
							}
						});		
					}
					deferred.resolve();
					return deferred.promise;
				}
				else if(actionType == 'serviceExternal'){
					var request = {};
					if(typeof serverConfig[currentEventInfo.action] == 'undefined'){
						Logger.fatal("Server configuration missing for the action :" + currentEventInfo.action);
						Logger.fatal("Aborting action now. Check your configuration in navigation/externalServersConfig.json and try again");
						deferred.reject();
						return deferred.promise;
					}
					Logger.info('serverConfig[currentEventInfo.action] : '+ serverConfig[currentEventInfo.action]);
					var serviceConfig = serverConfig[currentEventInfo.action];
					request.service = {};
					request.service.protocol = serviceConfig.protocol;
					request.service.host = serviceConfig.host;
					request.service.port = serviceConfig.port;
					request.service.apiEndpoint = serviceConfig.apiEndpoints[currentEventInfo.apiEndpoint];
					request.method = currentEventInfo.method;
					parameters.analytics = [$rootScope.analytics.deviceProfile,$rootScope.analytics.userProfile];
					request.data = parameters;

					//TODO: Improve error handling in serviceExternal
					HTTPConnector.invokeService(request).then(function(success){
						Logger.info("Invoked HTTP service successfuly : "+ JSON.stringify(success));
//						$injector.get(serviceConfig.serviceFactoryHandler[0])['init'](success,currentEventInfo.apiEndpoint);
						$injector.get(serviceConfig.serviceFactoryHandler[0]).init(success,currentEventInfo.apiEndpoint);
						deferred.resolve(success);
					},
					function(error){
						Logger.info("HTTP service invocation failed : "+ JSON.stringify(error));
						deferred.reject(error);
					});
					return deferred.promise;
				}
				/**
				 * If we are here, the type of action is service or serviceNoNavigation
				 * Sequence for handling service invocation is detailed below.
				 * The following execution is for workflows with type : service in the JSON configs.
				 * If the actiontype is "service", the following sequence of steps of will be
				 * executed.
				 * 1. Redirect the user to "loader" page
				 * 2. Invoke the service and check the response
				 * 3. If the service invocation was successful, take the user to the next page.
				 * 4. If the service invocation is an error, take the user to the error page (if error page is not
				 * defined, then take the user to the default error page)
				 */

				// Step 1: Let us execute the first step where the loading screen is displayed.
				if((typeof flag == 'undefined') && (actionType != "serviceNoNavigation")){
					if(isMbaasConnected){
						$location.path('/navigation/common/resources/FinacleLoaderPage');
					}
				}

				// Step 2: Invoke the service
//				parameters = getModelParameters(currentEventInfo);
//				Logger.info("Parameters to be posted are  " + JSON.stringify(parameters));
				var showLoaderFlag = true;
				if(actionType == "serviceNoNavigation"){
					showLoaderFlag = false;
					$rootScope.popoverObject = {
							eventName:eventName,
							response:null,
							isSuccess:false,
							isInProgress:true
					};
					Logger.info("serviceNoNavigation - flag set to false");
				}
				var invocationData = {
						adapter: service,
						procedure: "processRequest",
						parameters: parameters
				};
//				Logger.fatal("The invocation data is " + JSON.stringify(invocationData));
				invokeMFPHTTPService(invocationData, function(error,response){
					if(error){
						//handle error
						Logger.fatal("Error in MFP invocation :" + error );
						Logger.fatal('Service invocation returned an error');
						currentErrorResponse = error;

						// This is a minor hack and needs to be revisited.
						// There are situations where the backend returns a response
						// with an error message. In those situations, we will still
						// need to parse the response in the UI. Hence, we will set the
						// successreponse to the response we received from the caller.
						currentSuccessResponse = response;
						// Let us launch the error page
						var errorPage = currentEventInfo.errorPage;
						Logger.fatal('The error page is ' + JSON.stringify(errorPage));
						var pageUrl = TemplateProcessor.getUrlForPage(errorPage.pageName);
						Logger.fatal("The next page is " + errorPage + " with url " + pageUrl);

						// This action type will not just navigate but invoke service.
						if(actionType == 'serviceNoNavigation'){
							$rootScope.popoverObject = {
									eventName:eventName,
									response:currentSuccessResponse,
									isSuccess:true,
									isInProgress:false
							};
							deferred.resolve(response);
							return deferred.promise;
						}
						else{
							$location.path(pageUrl);
						}
						// We have all we need to move to the next page
						// Now that we have moved, let us remember which page we are in
						if (errorPage.hasOwnProperty('subFeature')) {
							// OK, we are moving to a new sub-feature
							currentSubFeature = errorPage.subFeature;
						}

						currentPage = errorPage.pageName;
						deferred.resolve(response);
						return;
					}

//					Logger.fatal("Success in MFP invocation :" + JSON.stringify(response));
					Logger.info('Service invocation was successful');
					
					
					//Check for adaptive/stepup authentication flow.
					if($rootScope.stepupAuthentication.isEnabled){
						$rootScope.stepupAuthentication.currentState = currentEventInfo.successPage;
						currentEventInfo.successPage = $rootScope.stepupAuthentication.format.successPage;
					}
					if($rootScope.stepupAuthentication.isCompleted){
						currentEventInfo.successPage = $rootScope.stepupAuthentication.currentState;
						$rootScope.stepupAuthentication.currentState = null;
						$rootScope.stepupAuthentication.isCompleted = false;
					}
					  if ($rootScope.stepupAuthentication.isErrorPage)
                      {
						 currentEventInfo.successPage = $rootScope.stepupAuthentication.currentState;
                         logoutFromMFPRealm();  
                      }
					
					// Let us launch the next page
					var nextActionObject = getNextActionSequenceObject(currentEventInfo);
					currentSuccessResponse = response;
					// This action type will not just navigate but invoke service.
					
					

					if(actionType == 'serviceNoNavigation'){
						$rootScope.popoverObject = {
								eventName:eventName,
								response:currentSuccessResponse,
								isSuccess:true,
								isInProgress:false
						};
						deferred.resolve(response);
						return deferred.promise;
					}
					else{
						$location.path(nextActionObject.pageUrl);
					}
					// We have all we need to move to the next page
					// Now that we have moved, let us remember which page we are in
					currentSubFeature = nextActionObject.nextSubFeatureName;
					currentPage = nextActionObject.nextPageName;
					deferred.resolve(response);
				},showLoaderFlag);
			}
			return deferred.promise;
		},
		getSuccessResponse:function(){
			return currentSuccessResponse;
		},
		getErrorResponse:function(){
			return currentErrorResponse;
		},
		// Method that fetches the entire literals mapping
		getLocalizedLiterals: function() {
			return TemplateProcessor.getLocalizedLiterals();
		}
	};
}]);
